/*
 * Copyright (C) 2014 BlackBerry Limited
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/* Kernel Includes */
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/timer.h>
#include <linux/err.h>
#include <linux/mm_types.h>
#include <linux/mm.h>
#include <linux/version.h>
#include <linux/vmalloc.h>
#include <linux/sched.h>
#include <linux/kallsyms.h>
#include <linux/fs.h>
#include <asm/sections.h>
#include <asm/uaccess.h>

/* QSEECOM Includes */
#include <qseecom_kernel.h>

/* Security Services Includes */
#include <tzbb_protocol_public.h>

/* Local Includes */
#include "bide.h"
#include "bide_internal.h"
#include "bide_log.h"

/*************************************************************************/

struct tz_data {
	nonce_data_t nonce;		/* A nonce generated by TZ. */
	bide_priv_key_store_t key;	/* HLOS private key store. */
	int key_init;	/* indicates the private key has been generated */
};

struct _tz_globals {
	struct qseecom_handle *handle;  /* Handle to TZ application. */
	struct tz_data tz;		/* TZ specific data. */
	struct mutex lock;		/* Thread safety */
};

static struct _tz_globals ctx = {};

/*************************************************************************/

#define BSIS_PATH_PUB_KEY	"/persist/bsis_publ"
#define BSIS_PATH_PRIV_KEY	"/persist/bsis_priv"
#define DEVICE_PIN_PATH		"/nvram/prdid/pin"

/*************************************************************************/

/*
 * This function reads the contents of a file.
 *
 * @param   fname           A strong containing the file to read.
 * @param   buf             A buffer to read data into.
 * @param   sz              Size of the buffer.
 *
 * @return  0               No Error.
 *	    -EINVAL         Invalid input value.
 */
static int tz_read_file(char *fname,
			void *buf,
			unsigned sz)
{
	struct file *fp = NULL;
	mm_segment_t fs;
	int rc = 0;

	if (!fname || !buf)
		return -EINVAL;

	/* Save the segment descriptor and associate it with the kernel */
	fs = get_fs();
	set_fs(get_ds());

	/* Open the dev node for reading */
	fp = filp_open(fname, O_NOFOLLOW | O_RDONLY, 0);
	if (!IS_ERR(fp)) {
		/* Read file contents */
		rc = fp->f_op->read(fp, buf, sz, &fp->f_pos);
		if (rc < 0)
			logError("Failed on read(%s). rc=%d.", fname, -rc);

		filp_close(fp, NULL);
	} else {
		rc = (int) -PTR_ERR(fp);
		logError("Failed on filp_open(%s). rc=%d.", fname, -rc);
	}

	/* Restore segment descriptor and close */
	set_fs(fs);

	return (rc < 0 ? rc : 0);
}

/*************************************************************************/

/*
 * Generate a hash from the nonce and counter.
 *
 * @param   hash            Pointer to a buffer that will receive the hash.
 * @param   sz              Size of the buffer.
 *
 * @return  0               No Error.
 *	    -EINVAL         Invalid input value.
 */
 static int tz_gen_nonce_hash(void *hash,
			      unsigned sz)
{
	/* Create a hash of the nonce */
	int rc = crypto_once(HASH_ALG_SHA512,
			     &ctx.tz.nonce,
			     sizeof(ctx.tz.nonce),
			     hash,
			     sz);

	if (rc) {
		logError("Failed on crypto_once(). rc=%d.", -rc);
		return rc;
	}

	return 0;
}

/*************************************************************************/

/*
 * This function calls into Trustzone with the given data.
 *
 * @param   cmd             The input command buffer.
 * @param   cmd_sz          Size of the command.
 * @param   rsp             A buffer that will receive the output.
 * @param   rsp_sz          Size of expected output.
 * @param   nonce           The nonce pointer within the cmd buffer.
 *
 * @return  0               No Error.
 *          -ENODEV         TZ has not been initialized properly.
 *          -EFAULT         SMC call was not successful.
 *          -EINVAL         Invalid input parameter value.
 *          -EBADE          TA did not return a valid status code.
 */
static int tz_call(void *cmd,
		   int cmd_sz,
		   void *rsp,
		   int rsp_sz,
		   void *nonce)
{
	/* First 4 bytes are always the command and status codes */
	int *status = (int *) rsp;
	int *command = (int *) cmd;
	int rc = 0;

	if (!ctx.handle)
		return -ENODEV;

	if (!cmd || !rsp)
		return -EINVAL;

	/* If nonce is required, generate a hash of it */
	if (nonce) {
		if (nonce < cmd ||
		    nonce + SHA512_SIZE > cmd + cmd_sz) {
			logError("Nonce is not within command struct.");
			return -EINVAL;
		}

		rc = tz_gen_nonce_hash(nonce, SHA512_SIZE);
		if (rc) {
			logError("Failed on tz_gen_nonce_hash(). rc=%d.", -rc);
			return rc;
		}
	}

	/* Crypto operations require high bandwidth to be set */
	rc = qseecom_set_bandwidth(ctx.handle, true);
	if (rc) {
		logError("Failed on qseecom_set_bandwidth(). rc=%d.", -rc);
		return rc;
	}

	/* Send the TZ command */
	rc = qseecom_send_command(ctx.handle, cmd, cmd_sz, rsp, rsp_sz);
	qseecom_set_bandwidth(ctx.handle, false);

	if (rc) {
		logError("Failed on qseecom_send_command(). rc=%d.", -rc);
		return rc;
	}

	/* Check the status code returned by TZ */
	if (*status) {
		logError("TZ returned bad status code. cmd=%d, status=%d.",
			*command, *status);

		return -EBADE;
	}

	/* Increase the nonce counter on a successful TZ transaction */
	ctx.tz.nonce.counter++;

	return 0;
}

/*************************************************************************/

/*
 * A helper funciton to map the input and output buffers to the qseecom
 * buffer.
 *
 * @param   cmd             The input buffer pointer that will be mapped.
 * @param   cmd_sz          Size of input buffer, aligned (in/out).
 * @param   rsp             The response buffer, mapped to an offset.
 * @param   rsp_sz          Size of response buffer, aligned (in/out).
 *
 * @return  0               No Error.
 *          -EINVAL         Bad input values.
 *          -ENOMEM         Internal qseecom buffer is too small.
 */
static int tz_init_buffers(void **cmd,
			   unsigned *cmd_sz,
			   void **rsp,
			   unsigned *rsp_sz)
{
	if (!cmd || !cmd_sz || !rsp || !rsp_sz)
		return -EINVAL;

	if (*cmd_sz & QSEECOM_ALIGN_MASK)
		*cmd_sz = QSEECOM_ALIGN(*cmd_sz);

	if (*rsp_sz & QSEECOM_ALIGN_MASK)
		*rsp_sz = QSEECOM_ALIGN(*rsp_sz);

	/* Check that the buffer is large enough for this data packet */
	if (*cmd_sz + *rsp_sz > ctx.handle->sbuf_len) {
		logError("Buffers too large to send to TZ.");
		return -ENOMEM;
	}

	*cmd = ctx.handle->sbuf;
	*rsp = ctx.handle->sbuf + *cmd_sz;

	/* Because the buffer is reused, wipe stale data */
	memset(ctx.handle->sbuf, 0, *cmd_sz + *rsp_sz);

	return 0;
}

/*************************************************************************/

/*
 * Generate a new key pair in trustzone.
 *
 * @param   ks              Destination struction for the BIDE key.
 * @param   p10             Destination struction for the p10 blob.
 *
 * @return  0               No Error.
 *          -EINVAL         Bad input values.
 *          -EFAULT         SMC call was not successful.
 *          -ENODEV         Bad handle value.
 *          -ERESTARTSYS    System interrupted mutex lock.
 */
int tz_gen_keypair(bide_keystore_t *ks,
		   bide_p10_t *p10)
{
	bide_generate_keypair_in_t *in = NULL;
	bide_generate_keypair_out_t *out = NULL;
	unsigned in_sz = sizeof(bide_generate_keypair_in_t);
	unsigned out_sz = sizeof(bide_generate_keypair_out_t);
	unsigned pin = 0;
	int rc = 0;

	if (!ctx.handle)
		return -ENODEV;

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	/* Initialize the buffers and sizes */
	rc = tz_init_buffers((void **) &in, &in_sz, (void **) &out, &out_sz);
	if (rc) {
		logError("Failed on tz_get_buffers(). rc=%d.", -rc);
		goto err;
	}

	/* Set up the command */
	in->cmd = TZ_CMD_BIDE_GENERATE_KEYPAIR;

	rc = tz_read_file(BSIS_PATH_PRIV_KEY,
			  &in->bsis_priv_key_store,
			  BSIS_KEYSTORE_SIZE);
	if (rc) {
		logError("Failed on tz_read_file(bsis). rc=%d.", -rc);
		goto err;
	}

	rc = tz_read_file(DEVICE_PIN_PATH,
			  &pin,
			  sizeof(pin));
	if (rc) {
		logError("Failed on tz_read_file(pin). rc=%d.", -rc);
		goto err;
	}

	rc = snprintf(in->pin, BBPIN_SIZE, "%X", pin);
	if (rc < 0) {
		logError("Failed on snprintf(pin). rc=%d.", -rc);
		goto err;
	}

	/* Send the command to TZ */
	rc = tz_call((void *) in, in_sz, (void *) out, out_sz, in->nonce_hash);
	if (rc) {
		logError("Failed on tz_call(). rc=%d.", -rc);
		goto err;
	}

	/* Make a local copy of the key */
	memcpy(&ctx.tz.key, &out->priv_key_store, sizeof(ctx.tz.key));
	ctx.tz.key_init = 1;

	/* If key is requested, copy it out */
	if (ks)
		memcpy(ks->data, &out->priv_key_store, BIDE_KEYSTORE_SIZE);

	/* Copy the P10 blob if it's requested */
	if (p10) {
		memcpy(p10->data, out->pkcs10, out->pkcs10_size);
		p10->sz = out->pkcs10_size;
	}

err:
	mutex_unlock(&ctx.lock);

	return rc;
}

/*************************************************************************/

/*
 * Sets the key for use in all TZ calls.
 *
 * @param   ks              Stored keys and IV data.
 *
 * @return  0               No Error.
 *          -EINVAL         Bad input values.
 *          -ERESTARTSYS    System interrupted mutex lock.
 */
int tz_set_keypair(bide_keystore_t *ks)
{
	if (!ks)
		return -EINVAL;

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	/* Make a local copy of the key */
	memcpy(&ctx.tz.key, ks->data, sizeof(ctx.tz.key));
	ctx.tz.key_init = 1;

	mutex_unlock(&ctx.lock);

	return 0;
}

/*************************************************************************/

/*
 * Sign a blob of data using the private key pair in trust zone.
 *
 * @param   krep            The KBIDE report buffer.
 * @param   krep_sz         Size of KBIDE report buffer.
 * @param   tzrep           A buffer that will receive the TZ report.
 * @param   tzrep_sz        Size of TZ buffer, must be BIDE_MAX_REPORT_SIZE.
 * @param   sig             The resulting signature of signed report.
 * @param   sig_sz          Size of buffer, must be ECC256_SIG_SIZE.
 *
 * @return  0               No Error.
 *          -ENODEV         TZ has not been initialized properly.
 *          -EFAULT         SMC call was not successful.
 *          -EINVAL         Bad input parameters.
 *          -ERESTARTSYS    System interrupted mutex lock.
 */
int tz_sign_data(char *krep,
		 unsigned krep_sz,
		 char *tzrep,
		 unsigned tzrep_sz,
		 uint8_t *sig,
		 unsigned sig_sz)
{
	bide_sign_data_in_t *in = NULL;
	bide_sign_data_out_t *out = NULL;
	unsigned in_sz = sizeof(bide_sign_data_in_t);
	unsigned out_sz = sizeof(bide_sign_data_out_t);
	uint8_t hash[HASH_SHA256_SIZE] = { 0 };
	int rc = 0;

	if ((!ctx.handle) || (!ctx.tz.key_init)) {
		logError("Context not initialized. handle=%p key_init=%d",
			ctx.handle, ctx.tz.key_init);
		return -ENODEV;
	}

	if (!krep || !krep_sz ||
	    !tzrep || tzrep_sz < BIDE_MAX_REPORT_SIZE ||
	    !sig || sig_sz < ECC256_SIG_SIZE)
		return -EINVAL;

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	/* Initialize the buffers and sizes */
	rc = tz_init_buffers((void **) &in, &in_sz, (void **) &out, &out_sz);
	if (rc) {
		logError("Failed on tz_get_buffers(). rc=%d.", -rc);
		goto err;
	}

	/* Generate a hash of the data */
	rc = crypto_once(HASH_ALG_SHA256, krep, krep_sz, hash, sizeof(hash));
	if (rc) {
		logError("Failed on crypto_once(). rc=%d.", -rc);
		goto err;
	}

	/* Create an base64 encoded string of the hash */
	rc = util_base64_encode(hash,
				sizeof(hash),
				in->report_hash,
				sizeof(in->report_hash));
	if (rc < 0) {
		logError("Failed on util_base64_encode(). rc=%d.", -rc);
		goto err;
	}

	/* Set up the command */
	in->cmd = TZ_CMD_BIDE_SIGN_DATA;
	memcpy(&in->priv_key_store, &ctx.tz.key, sizeof(ctx.tz.key));

	/* Send the command to TZ */
	rc = tz_call((void *) in, in_sz, (void *) out, out_sz, in->nonce_hash);
	if (rc) {
		logError("Failed on tz_call(). rc=%d.", -rc);
		goto err;
	}

	/* If successful, copy the data out */
	memcpy(tzrep, out->report, BIDE_MAX_REPORT_SIZE);
	memcpy(sig, out->signature, ECC256_SIG_SIZE);

err:
	mutex_unlock(&ctx.lock);

	return rc;
}

/*************************************************************************/

/*
 * Requests a nonce from the TA. Once a nonce has been requested, no other
 * add section calls to TZ can be made.
 *
 * @return  0               No Error.
 *          -ENODEV         TZ has not been initialized properly.
 *          -EFAULT         SMC call was not successful.
 *          -EINVAL         Bad handle value.
 *          -ERESTARTSYS    System interrupted mutex lock.
 */
int tz_get_nonce(void)
{
	bide_generate_nonce_in_t *in = NULL;
	bide_generate_nonce_out_t *out = NULL;
	unsigned in_sz = sizeof(bide_generate_nonce_in_t);
	unsigned out_sz = sizeof(bide_generate_nonce_out_t);
	int rc = 0;

	if (!ctx.handle)
		return -ENODEV;

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	/* Initialize the buffers and sizes */
	rc = tz_init_buffers((void **) &in, &in_sz, (void **) &out, &out_sz);
	if (rc) {
		logError("Failed on tz_get_buffers(). rc=%d.", -rc);
		goto err;
	}

	/* Set up the command */
	in->cmd = TZ_CMD_BIDE_GENERATE_NONCE;

	/* Send the command to TZ */
	rc = tz_call((void *) in, in_sz, (void *) out, out_sz, NULL);
	if (rc) {
		logError("Failed on tz_call(). rc=%d.", -rc);
		goto err;
	}

	/* Save the nonce, reset counter */
	memcpy(ctx.tz.nonce.session, out->nonce, BIDE_NONCE_SIZE);
	ctx.tz.nonce.counter = 0;

err:
	mutex_unlock(&ctx.lock);

	return rc;
}

/*************************************************************************/

/*
 * This function adds a pointer to a section of memory that TZ will
 * periodically hash and verify. The first call to this function must pass
 * the kernel's text section pointer.
 *
 * @param   p               A pointer to physical memory to add.
 * @param   sz              Size of the memory section.
 *
 * @return  0               No Error.
 *          -ENODEV         TZ has not been initialized properly.
 *          -EFAULT         SMC call was not successful.
 *          -ERESTARTSYS    System interrupted mutex lock.
 */
int tz_add_section(void *p,
		   unsigned sz)
{
	bide_add_section_in_t *in = NULL;
	bide_add_section_out_t *out = NULL;
	unsigned in_sz = sizeof(bide_add_section_in_t);
	unsigned out_sz = sizeof(bide_add_section_out_t);
	int rc = 0;

	if (!ctx.handle)
		return -ENODEV;

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	/* Initialize the buffers and sizes */
	rc = tz_init_buffers((void **) &in, &in_sz, (void **) &out, &out_sz);
	if (rc) {
		logError("Failed on tz_get_buffers(). rc=%d.", -rc);
		goto err;
	}


	/* Set up the command */
	in->cmd   = TZ_CMD_BIDE_ADD_SECTION;
	in->addr  = (uint32_t) (unsigned long) p;
	in->size  = sz;
	in->flags = 0;

	/* Send the command to TZ */
	rc = tz_call((void *) in, in_sz, (void *) out, out_sz, in->nonce_hash);
	if (rc) {
		logError("Failed on tz_call(). rc=%d.", -rc);
		goto err;
	}

err:
	mutex_unlock(&ctx.lock);

	return rc;
}

/*************************************************************************/

/*
 * This function removes a section of memory from TZ. The first section,
 * which is reserved for the kernel itself, will never be removed.
 *
 * @param   p               A pointer to a physical memory section.
 * @param   sz              Size of the memory section.
 *
 * @return  0               No Error.
 *          -ENODEV         TZ has not been initialized properly.
 *          -EFAULT         SMC call was not successful.
 *          -ERESTARTSYS    System interrupted mutex lock.
 */
int tz_remove_section(void *p,
		      unsigned sz)
{
	bide_remove_section_in_t *in = NULL;
	bide_remove_section_out_t *out = NULL;
	unsigned in_sz = sizeof(bide_remove_section_in_t);
	unsigned out_sz = sizeof(bide_remove_section_out_t);
	int rc = 0;

	if (!ctx.handle)
		return -ENODEV;

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	/* Initialize the buffers and sizes */
	rc = tz_init_buffers((void **) &in, &in_sz, (void **) &out, &out_sz);
	if (rc) {
		logError("Failed on tz_get_buffers(). rc=%d.", -rc);
		goto err;
	}

	/* Set up the command */
	in->cmd  = TZ_CMD_BIDE_REMOVE_SECTION;
	in->addr = (uint32_t) (unsigned long) p;
	in->size = sz;

	/* Send the command to TZ */
	rc = tz_call((void *) in, in_sz, (void *) out, out_sz, in->nonce_hash);
	if (rc) {
		logError("Failed on tz_call(). rc=%d.", -rc);
		goto err;
	}

err:
	mutex_unlock(&ctx.lock);

	return rc;
}

/*************************************************************************/

/*
 * This function initializes the trustzone handle and calls into it to add
 * the kernel text section for hashing.
 *
 * @return  0               No Error.
 *          -EFAULT         SMC call was not successful.
 *          -EINVAL         Bad handle value.
 *          -ERESTARTSYS    System interrupted mutex lock.
 */
int tz_init_kernel(void)
{
	int rc = 0;

	/* If already initialized, ignore subsequent attempt */
	if (ctx.handle)
		return 0;

	logInfo("Initializing TZ.");

	/* Open a handle to the BlackBerry TA and allocate a page */
	rc = qseecom_start_app(&ctx.handle, "blackber", PAGE_SIZE);
	if (rc) {
		logError("Failed on qseecom_start_app(). rc=%d.", -rc);
		return rc;
	}

	/* Before any operation, secure the channel to TZ */
	rc = tz_get_nonce();
	if (rc) {
		logError("Failed on tz_get_nonce(). rc=%d.", -rc);
		return rc;
	}

	return 0;
}

/*************************************************************************/

/*
 * Clean up routine when system is being shut down.
 *
 * @return  0                   No Error.
 *          -EFAULT             SMC call was not successful.
 *          -EINVAL             Bad handle value.
 */
int tz_exit(void)
{
	/* Clean up handle */
	int rc = qseecom_shutdown_app(&ctx.handle);
	if (rc)
		logError("Failed on qseecom_shutdown_app(). rc=%d.", -rc);

	/* Free up mutex */
	mutex_destroy(&ctx.lock);

	return rc;
}

/*************************************************************************/

/*
 * Entry point for initialization.
 *
 * @return  0                   No Error.
 *          -ENOMEM             Out of memory for handle allocaiton.
 *          -EINVAL             Bad handle value.
 *          -EIO                Cannot load image.
 */
int tz_init(void)
{
	/* Initialize Mutex */
	mutex_init(&ctx.lock);

	return 0;
}
