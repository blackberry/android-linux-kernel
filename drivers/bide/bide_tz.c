/*
 * Copyright (C) 2018 BlackBerry Limited
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/* Kernel Includes */
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/timer.h>
#include <linux/err.h>
#include <linux/mm_types.h>
#include <linux/mm.h>
#include <linux/version.h>
#include <linux/vmalloc.h>
#include <linux/sched.h>
#include <linux/kallsyms.h>
#include <linux/fs.h>
#include <asm/sections.h>
#include <asm/uaccess.h>

/* QSEECOM Includes */
#include <qseecom_kernel.h>

/* Security Services Includes */
#include <tzbb_protocol_public.h>

/* Local Includes */
#include "bide.h"
#include "bide_internal.h"
#include "bide_log.h"

/*************************************************************************/

struct tz_data {
	nonce_data_t nonce;		/* A nonce generated by TZ. */
	bide_priv_key_store_t key;	/* HLOS private key store. */
	int key_init;	/* indicates the private key has been generated */
};

struct _tz_globals {
	struct qseecom_handle *handle;  /* Handle to TZ application. */
	struct tz_data tz;		/* TZ specific data. */
	struct mutex lock;		/* Thread safety */
	uint32_t build_version; 	/* Id of the build version */
};

static struct _tz_globals ctx = {};

/*************************************************************************/

#define BSIS_PATH_PRIV_KEY      "/bbpersist/bsis_priv"
#define BSIS_PATH_PRIV_KEY_OLD  "/persist/bsis_priv"
#define DEVICE_PIN_PATH         "/nvram/prdid/pin"

/*************************************************************************/

/*
 * This function reads the contents of a file.
 *
 * @param   fname           A string containing the file to read.
 * @param   buf             A buffer to read data into.
 * @param   sz              Size of the buffer.
 *
 * @return  0               No Error.
 *	    -EINVAL         Invalid input value.
 */
static int tz_read_file(char *fname,
			void *buf,
			unsigned sz)
{
	struct file *fp = NULL;
	mm_segment_t fs;
	int rc = 0;

	if (!fname || !buf)
		return -EINVAL;

	/* Save the segment descriptor and associate it with the kernel */
	fs = get_fs();
	set_fs(get_ds());
	/* Open the dev node for reading */
	fp = filp_open(fname, O_NOFOLLOW | O_RDONLY, 0);

	if (!IS_ERR(fp)) {
		/* Read file contents */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
		rc = kernel_read(fp, 0, buf, sz);
#else
		rc = fp->f_op->read(fp, buf, sz, &fp->f_pos);
#endif
		if (rc < 0)
			logError("Failed on read(%s). rc=%d.", fname, rc);

		filp_close(fp, NULL);
	} else {
		rc = (int) PTR_ERR(fp);
		logError("Failed on filp_open(%s). rc=%d.", fname, rc);
	}

	/* Restore segment descriptor and close */
	set_fs(fs);

	return (rc < 0 ? rc : 0);
}

/*************************************************************************/

/*
 * Generate a hash from the nonce and counter.
 *
 * @param   hash            Pointer to a buffer that will receive the hash.
 * @param   sz              Size of the buffer.
 *
 * @return  0               No Error.
 *	    -EINVAL         Invalid input value.
 */
 static int tz_gen_nonce_hash(void *hash,
			      unsigned sz)
{
	/* Create a hash of the nonce */
	int rc = crypto_once(HASH_ALG_SHA512,
			     &ctx.tz.nonce,
			     sizeof(ctx.tz.nonce),
			     hash,
			     sz);

	if (rc) {
		logError("Failed on crypto_once(). rc=%d.", -rc);
		return rc;
	}

	return 0;
}

/*************************************************************************/

/*
 * This function calls into Trustzone with the given data.
 *
 * @param   cmd             The input command buffer.
 * @param   cmd_sz          Size of the command.
 * @param   rsp             A buffer that will receive the output.
 * @param   rsp_sz          Size of expected output.
 * @param   nonce           The nonce pointer within the cmd buffer.
 *
 * @return  0               No Error.
 *          -ENODEV         TZ has not been initialized properly.
 *          -EFAULT         SMC call was not successful.
 *          -EINVAL         Invalid input parameter value.
 *          -EBADE          TA did not return a valid status code.
 *          -TZ_BIDE_NONCE_HASH_MISMATCH_PUBLIC   Nonce mismatch.
 */
static int tz_call(void *cmd,
		   int cmd_sz,
		   void *rsp,
		   int rsp_sz,
		   void *nonce)
{
	/* First 4 bytes are always the command and status codes */
	int *status = (int *) rsp;
	int *command = (int *) cmd;
	int rc = 0;

	if (!ctx.handle)
		return -ENODEV;

	if (!cmd || !rsp)
		return -EINVAL;

	/* If nonce is required, generate a hash of it */
	if (nonce) {
		if (nonce < cmd ||
		    nonce + SHA512_SIZE > cmd + cmd_sz) {
			logError("Nonce is not within command struct.");
			return -EINVAL;
		}

		rc = tz_gen_nonce_hash(nonce, SHA512_SIZE);
		if (rc) {
			logError("Failed on tz_gen_nonce_hash(). rc=%d.", -rc);
			return rc;
		}
	}

	/* Crypto operations require high bandwidth to be set */
	rc = qseecom_set_bandwidth(ctx.handle, true);
	if (rc) {
		logError("Failed on qseecom_set_bandwidth(). rc=%d.", -rc);
		return rc;
	}

	/* Send the TZ command */
	rc = qseecom_send_command(ctx.handle, cmd, cmd_sz, rsp, rsp_sz);
	qseecom_set_bandwidth(ctx.handle, false);

	if (rc) {
		logError("Failed on qseecom_send_command(). rc=%d.", -rc);
		return rc;
	}

	/* Check the status code returned by TZ */
	if (*status) {
		logError("TZ returned bad status code. cmd=%d, status=%d.",
			*command, *status);

		if ((*status) == TZ_BIDE_NONCE_HASH_MISMATCH_PUBLIC) {
			return -TZ_BIDE_NONCE_HASH_MISMATCH_PUBLIC;
		}
		return -EBADE;
	}

	/* Increase the nonce counter on a successful TZ transaction */
	if (nonce)
		ctx.tz.nonce.counter++;

	return 0;
}

/*************************************************************************/

/*
 * A helper function to map the input and output buffers to the qseecom
 * buffer.
 *
 * @param   cmd             The input buffer pointer that will be mapped.
 * @param   cmd_sz          Size of input buffer, aligned (in/out).
 * @param   rsp             The response buffer, mapped to an offset.
 * @param   rsp_sz          Size of response buffer, aligned (in/out).
 *
 * @return  0               No Error.
 *          -EINVAL         Bad input values.
 *          -ENOMEM         Internal qseecom buffer is too small.
 */
static int tz_init_buffers(void **cmd,
			   unsigned *cmd_sz,
			   void **rsp,
			   unsigned *rsp_sz)
{
	if (!cmd || !cmd_sz || !rsp || !rsp_sz)
		return -EINVAL;

	if (*cmd_sz & QSEECOM_ALIGN_MASK)
		*cmd_sz = QSEECOM_ALIGN(*cmd_sz);

	if (*rsp_sz & QSEECOM_ALIGN_MASK)
		*rsp_sz = QSEECOM_ALIGN(*rsp_sz);

	/* Check that the buffer is large enough for this data packet */
	if (*cmd_sz + *rsp_sz > ctx.handle->sbuf_len) {
		logError("Buffers too large to send to TZ.");
		return -ENOMEM;
	}

	*cmd = ctx.handle->sbuf;
	*rsp = ctx.handle->sbuf + *cmd_sz;

	/* Because the buffer is reused, wipe stale data */
	memset(ctx.handle->sbuf, 0, *cmd_sz + *rsp_sz);

	return 0;
}

/*************************************************************************/

/*
 * Generate a new key pair in trustzone.
 *
 * @param   ks              Destination struction for the BIDE key.
 * @param   p10             Destination struction for the p10 blob.
 *
 * @return  0               No Error.
 *          -EINVAL         Bad input values.
 *          -EFAULT         SMC call was not successful.
 *          -ENODEV         Bad handle value.
 *          -ERESTARTSYS    System interrupted mutex lock.
 *          -TZ_BIDE_NONCE_HASH_MISMATCH_PUBLIC   Nonce mismatch.
 */
int tz_gen_keypair(bide_keystore_t *ks,
		   bide_p10_t *p10)
{
	bide_generate_keypair_in_t *in = NULL;
	bide_generate_keypair_out_t *out = NULL;
	unsigned in_sz = sizeof(bide_generate_keypair_in_t);
	unsigned out_sz = sizeof(bide_generate_keypair_out_t);

	unsigned pin = 0;
	int rc = 0;

	if (!ctx.handle)
		return -ENODEV;

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	/* Initialize the buffers and sizes */
	rc = tz_init_buffers((void **) &in, &in_sz, (void **) &out, &out_sz);
	if (rc) {
		logError("Failed on tz_get_buffers(). rc=%d.", -rc);
		goto err;
	}

	/* Set up the command */
	in->cmd = TZ_CMD_BIDE_GENERATE_KEYPAIR;

	rc = tz_read_file(BSIS_PATH_PRIV_KEY,
			  &in->bsis_priv_key_store,
			  BSIS_KEYSTORE_SIZE);
	if (rc) {
		/* check old location in case we have an old rev device */
		rc = tz_read_file(BSIS_PATH_PRIV_KEY_OLD,
			  &in->bsis_priv_key_store,
			  BSIS_KEYSTORE_SIZE);
		if (rc) {
			logError("Failed on tz_read_file(BSIS). rc=%d.", -rc);
			goto err;
		}
	}

	rc = tz_read_file(DEVICE_PIN_PATH,
			  &pin,
			  sizeof(pin));
	if (rc) {
		logError("Failed on tz_read_file(pin). rc=%d.", -rc);
		goto err;
	}

	rc = snprintf(in->pin, BBPIN_SIZE, "%X", pin);
	if (rc < 0) {
		logError("Failed on snprintf(pin). rc=%d.", -rc);
		goto err;
	}

	/* Send the command to TZ */
	rc = tz_call((void *) in, in_sz, (void *) out, out_sz, in->nonce_hash);
	if (rc) {
		logError("Failed on tz_call(). rc=%d.", -rc);
		goto err;
	}

	/* Make a local copy of the key if there is no existing one */
	if (ctx.tz.key_init == 0) {
		memcpy(&ctx.tz.key, &out->priv_key_store, sizeof(ctx.tz.key));
		ctx.tz.key_init = 1;
	}

	/* If key is requested, copy it out */
	if (ks)
		memcpy(ks->data, &out->priv_key_store, BIDE_KEYSTORE_SIZE);

	/* Copy the P10 blob if it's requested */
	if (p10) {
		memcpy(p10->data, out->pkcs10, out->pkcs10_size);
		p10->sz = out->pkcs10_size;
	}

err:
	mutex_unlock(&ctx.lock);

	return rc;
}

/*************************************************************************/

/*
 * Sets the key for use in all TZ calls.
 *
 * @param   ks              Stored keys and IV data.
 *
 * @return  0               No Error.
 *          -EINVAL         Bad input values.
 *          -ERESTARTSYS    System interrupted mutex lock.
 */
int tz_set_keypair(bide_keystore_t *ks)
{
	if (!ks)
		return -EINVAL;

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	/* Make a local copy of the key */
	memcpy(&ctx.tz.key, ks->data, sizeof(ctx.tz.key));
	ctx.tz.key_init = 1;

	mutex_unlock(&ctx.lock);

	return 0;
}

/*************************************************************************/

/*
 * Test the BID private and Public Key pair.
 *
 * @param   ks              The keypair to test.
 *
 * @return  0               No Error.
 *          -EINVAL         Bad input values.
 *          -ERESTARTSYS    System interrupted mutex lock.
 *          -1              The keypair does not match
 */
int tz_verify_keypair(bide_keystore_t *ks)
{
	bide_validate_keypair_in_t *in = NULL;
	bide_validate_keypair_out_t *out = NULL;
	unsigned in_sz = sizeof(bide_validate_keypair_in_t);
	unsigned out_sz = sizeof(bide_validate_keypair_out_t);
	int rc = -1;

	if ((!ks) || (sizeof(ks->pub_key) != ECC256_PUBL_KEY_SIZE))
		return -EINVAL;

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	/* Initialize the buffers and sizes */
	rc = tz_init_buffers((void **) &in, &in_sz, (void **) &out, &out_sz);
	if (rc) {
		logError("Failed on tz_get_buffers(). rc=%d.", -rc);
		goto err;
	}

	memset(in, 0, sizeof(bide_validate_keypair_in_t));

	/* Set up the command */
	in->cmd = TZ_CMD_BIDE_VALIDATE_KEYPAIR;

	memcpy(in->public_key, ks->pub_key, ECC256_PUBL_KEY_SIZE);
	memcpy(&in->priv_key_store, &ctx.tz.key, sizeof(ctx.tz.key));

	/* Send the command to TZ */
	rc = tz_call((void *) in, in_sz, (void *) out, out_sz, in->nonce_hash);
	if (rc) {
		logError("Failed on tz_call(). rc=%d.", -rc);
		goto err;
	}

	logInfo("tz_verify_keypair() status=%d", out->status);

	if (0 != out->status)
		rc = -1;

err:
	mutex_unlock(&ctx.lock);

	return rc;
}

/*************************************************************************/

/*
 * Sign a blob of data using the private key pair in trust zone.
 *
 * @param   krep            The KBIDE report buffer.
 * @param   krep_sz         Size of KBIDE report buffer.
 * @param   tzrep           A buffer that will receive the TZ report.
 * @param   tzrep_sz        Size of TZ buffer, must be BIDE_MAX_REPORT_SIZE.
 * @param   sig             The resulting signature of signed report.
 * @param   sig_sz          Size of buffer, must be ECC256_SIG_SIZE.
 *
 * @return  0               No Error.
 *          -ENODEV         TZ has not been initialized properly.
 *          -EFAULT         SMC call was not successful.
 *          -EINVAL         Bad input parameters.
 *          -ERESTARTSYS    System interrupted mutex lock.
 *          -TZ_BIDE_NONCE_HASH_MISMATCH_PUBLIC   Nonce mismatch.
 */
int tz_sign_data(char *krep,
		 unsigned krep_sz,
		 char *tzrep,
		 unsigned tzrep_sz,
		 uint8_t *sig,
		 unsigned sig_sz)
{
	bide_sign_data_in_t *in = NULL;
	bide_sign_data_out_t *out = NULL;
	unsigned in_sz = sizeof(bide_sign_data_in_t);
	unsigned out_sz = sizeof(bide_sign_data_out_t);
	uint8_t hash[SHA256_SIZE] = { 0 };
	int rc = 0;

	if ((!ctx.handle) || (!ctx.tz.key_init)) {
		logError("ctx not init. h=%p k=%d", ctx.handle, ctx.tz.key_init);
		return -ENODEV;
	}

	if (!krep || !krep_sz ||
	    !tzrep || tzrep_sz < BIDE_MAX_REPORT_SIZE ||
	    !sig || sig_sz < ECC256_SIG_SIZE)
		return -EINVAL;

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	/* Initialize the buffers and sizes */
	rc = tz_init_buffers((void **) &in, &in_sz, (void **) &out, &out_sz);
	if (rc) {
		logError("Failed on tz_get_buffers(). rc=%d.", -rc);
		goto err;
	}

	/* Generate a hash of the data */
	rc = crypto_once(HASH_ALG_SHA256, krep, krep_sz, hash, sizeof(hash));
	if (rc) {
		logError("Failed on crypto_once(). rc=%d.", -rc);
		goto err;
	}

	/* Create an base64 encoded string of the hash */
	rc = util_base64_encode(hash,
				sizeof(hash),
				in->report_hash,
				sizeof(in->report_hash));
	if (rc < 0) {
		logError("Failed on util_base64_encode(). rc=%d.", -rc);
		goto err;
	}

	/* Set up the command */
	in->cmd = TZ_CMD_BIDE_SIGN_DATA;
	memcpy(&in->priv_key_store, &ctx.tz.key, sizeof(ctx.tz.key));

	/* Send the command to TZ */
	rc = tz_call((void *) in, in_sz, (void *) out, out_sz, in->nonce_hash);
	if (rc) {
		logError("Failed on tz_call(). rc=%d.", -rc);
		goto err;
	}

	/* If successful, copy the data out */
	memcpy(tzrep, out->report, BIDE_MAX_REPORT_SIZE);
	memcpy(sig, out->signature, ECC256_SIG_SIZE);

err:
	mutex_unlock(&ctx.lock);

	return rc;
}

/*************************************************************************/

/*
 * Calls trustzone to set the build version.
 *
 * @param   build_version   build version to set
 *
 * @return  0               No Error.
 *          -ERESTARTSYS    System interrupted mutex lock.
 *          -EINVAL         Invalid build number
 */
int tz_set_build_version(build_version_t* build_version_str)
{
	int rc = 0;

	if (!build_version_str)
		return -EINVAL;

	logInfo("tz_set_build_version %s", (char *) build_version_str);

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	rc = utils_bide_storage_build_to_number(*build_version_str,
				&ctx.build_version);
	if (rc)
		logError("Failed utils_bide_storage_build_to_number(%s). rc=%d.", (char *) build_version_str, -rc);

	mutex_unlock(&ctx.lock);

	return rc;
}

/*************************************************************************/

/*
 * Asks trustzone to dirty a sensor.
 *
 * @param   sensor          Sensor to dirty
 * @param   called_from     Report triggered by JBide or KBide
 *
 * @return  0               No Error.
 *          -EINVAL         Bad input parameters.
 *          -ENODEV         TZ has not been initialized properly.
 *          -ERESTARTSYS    System interrupted mutex lock.
 *          -EBADE          TA did not return a valid status code.
 */
int tz_set_compromised_state(uint32_t sensor, unsigned called_from)
{
	int rc = 0;
	bide_storage_update_sensor_in_t *in = NULL;
	bide_storage_update_sensor_out_t *out = NULL;
	unsigned in_sz = sizeof(bide_storage_update_sensor_in_t);
	unsigned out_sz = sizeof(bide_storage_update_sensor_out_t);

	logInfo("tz_set_compromised_state (%d, %d)", sensor, called_from);

	if (!ctx.handle) {
		logError("Context not initialized. handle=NUL");
		return -ENODEV;
	}

	if (called_from != KBIDE && called_from != JBIDE)
		return -EINVAL;

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	if (ctx.build_version == 0) {
		logError("Invalid build version.");
		rc = -EINVAL;
		goto cleanup;
	}

	/* Initialize the buffers and sizes */
	rc = tz_init_buffers((void **) &in, &in_sz, (void **) &out, &out_sz);
	if (rc) {
		logError("Failed on tz_init_buffers(). rc=%d.", -rc);
		goto cleanup;
	}

	/* Set up the command */
	in->cmd = TZ_CMD_BIDE_STORAGE_UPDATE_SENSOR;
	in->sensor_type = (called_from == KBIDE) ? KBIDE_SENSOR : JBIDE_SENSOR;
	in->sensor_index = sensor;
	in->os_version = ctx.build_version;

	rc = tz_call((void *) in, in_sz, (void *) out, out_sz, NULL);
	if (rc)
		logError("Failed on tz_call() from compr_state. rc=%d.", -rc);

cleanup:
	mutex_unlock(&ctx.lock);
	return rc;
}

/*************************************************************************/

/*
 * Request the current status of the RPMB sensors from Trustzone.
 *
 * @param   kbide_sensors   Out: Pointer to an array in which the status of
 *                          the kbide sensors from trustzone will be copied
 * @param   kbide_sz        Size of kbide_sensors
 * @param   jbide_sensors   Out: Pointer to an array in which the status of
 *                          the jbide sensors from trustzone will be copied
 * @param   jbide_sz        Size of jbide_sensors
 *
 * @return  0               No Error.
 *          -EINVAL         Bad input parameters.
 *          -ENODEV         TZ has not been initialized properly.
 *          -ERESTARTSYS    System interrupted mutex lock.
 *          -EBADE          TA did not return a valid status code.
 */
int tz_read_sensor_state(uint32_t *kbide_sensors, unsigned kbide_sz,
			uint32_t *jbide_sensors, unsigned jbide_sz)
{
	int rc = 0;
	bide_storage_read_in_t *in  = NULL;
	bide_storage_read_out_t *out = NULL;
	unsigned in_sz = sizeof(bide_storage_read_in_t);
	unsigned out_sz = sizeof(bide_storage_read_out_t);

	if (!ctx.handle) {
		logError("Context not initialized. handle=NUL");
		return -ENODEV;
	}

	if (!kbide_sensors || !jbide_sensors ||
		kbide_sz != BIDE_STORAGE_NUMBER_SENSORS ||
		jbide_sz != BIDE_STORAGE_NUMBER_SENSORS)
		return -EINVAL;

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	/* Initialize the buffers and sizes */
	rc = tz_init_buffers((void **) &in, &in_sz, (void **) &out, &out_sz);
	if (rc) {
		logError("Failed on tz_get_buffers(). rc=%d.", -rc);
		goto cleanup;
	}

	/* Set up the command */
	in->cmd = TZ_CMD_BIDE_STORAGE_READ;

	rc = tz_call((void *) in, in_sz, (void *) out, out_sz, NULL);
	if (rc) {
		logError("Failed on tz_call() from read_sensor. rc=%d.", -rc);
		goto cleanup;
	}

	/* Copy in caller's memory */
	memcpy(kbide_sensors, out->kbide, kbide_sz*sizeof(uint32_t));
	memcpy(jbide_sensors, out->jbide, jbide_sz*sizeof(uint32_t));

cleanup:
	mutex_unlock(&ctx.lock);
	return rc;
}

/*************************************************************************/

/*
 * Requests a nonce from the TA. Once a nonce has been requested, no other
 * add section calls to TZ can be made.
 *
 * @return  0               No Error.
 *          -ENODEV         TZ has not been initialized properly.
 *          -EFAULT         SMC call was not successful.
 *          -EINVAL         Bad handle value.
 *          -ERESTARTSYS    System interrupted mutex lock.
 *          -TZ_BIDE_NONCE_HASH_MISMATCH_PUBLIC   Nonce mismatch.
 */
int tz_get_nonce(void)
{
	bide_generate_nonce_in_t *in = NULL;
	bide_generate_nonce_out_t *out = NULL;
	unsigned in_sz = sizeof(bide_generate_nonce_in_t);
	unsigned out_sz = sizeof(bide_generate_nonce_out_t);
	int rc = 0;

	if (!ctx.handle)
		return -ENODEV;

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	/* Initialize the buffers and sizes */
	rc = tz_init_buffers((void **) &in, &in_sz, (void **) &out, &out_sz);
	if (rc) {
		logError("Failed on tz_init_buffers() in tz_get_nonce(). rc=%d.", -rc);
		goto err;
	}

	/* Set up the command */
	in->cmd = TZ_CMD_BIDE_GENERATE_NONCE;

	/* Send the command to TZ */
	rc = tz_call((void *) in, in_sz, (void *) out, out_sz, NULL);
	if (rc) {
		logError("Failed on tz_call() in tz_get_nonce(). rc=%d.", -rc);
		goto err;
	}

	/* Save the nonce, reset counter */
	memcpy(ctx.tz.nonce.session, out->nonce, BIDE_NONCE_SIZE);
	ctx.tz.nonce.counter = 0;

err:
	mutex_unlock(&ctx.lock);

	return rc;
}

/*************************************************************************/

/*
 * This function adds a pointer to a section of memory that TZ will
 * periodically hash and verify. The first call to this function
 * from thread_proc will pass the kernel's text section pointer,
 * and its hash, for extra verification.
 *
 * @param   p               A pointer to physical memory to add.
 * @param   sz              Size of the memory section.
 *
 * @return  0               No Error.
 *          -ENODEV         TZ has not been initialized properly.
 *          -EFAULT         SMC call was not successful.
 *          -ERESTARTSYS    System interrupted mutex lock.
 *          -TZ_BIDE_NONCE_HASH_MISMATCH_PUBLIC   Nonce mismatch.
 */
int tz_add_section(void *p,
		   unsigned sz)
{
	bide_add_section_in_t *in = NULL;
	bide_add_section_out_t *out = NULL;
	unsigned in_sz = sizeof(bide_add_section_in_t);
	unsigned out_sz = sizeof(bide_add_section_out_t);
	int rc = 0;
	void *kern_beg = (void *) (unsigned long) _stext;
	void *kern_end = (void *) (unsigned long) _etext;
	void *phys_kern_beg = (void *) virt_to_phys(kern_beg);

	if (!ctx.handle)
		return -ENODEV;

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	/* Initialize the buffers and sizes */
	rc = tz_init_buffers((void **) &in, &in_sz, (void **) &out, &out_sz);
	if (rc) {
		logError("Failed on tz_get_buffers(). rc=%d.", -rc);
		goto err;
	}

	/* Set up the command */
	in->cmd   = TZ_CMD_BIDE_ADD_SECTION;
	in->addr  = (uint32_t) (unsigned long) p;
	in->size  = sz;
	in->flags = 0;

	/* Special case: hash kernel code and pass it to TZ for check */
	if (p == phys_kern_beg) {
		in->flags |= TZ_SECTION_FLAG_CONFIRM_KNOWN_HASH;

		/* Yes, crypto_once needs virtual starting address, not physical like for TZ */
		rc = crypto_once(HASH_ALG_SHA256, kern_beg, (unsigned) (kern_end-kern_beg), in->mem_hash, sizeof(in->mem_hash));
		if (rc)
			logError("Failed on crypto_once in tz_add_section(). rc=%d.", -rc);
	}

	/* Send the command to TZ */
	rc = tz_call((void *) in, in_sz, (void *) out, out_sz, in->nonce_hash);
	if (rc) {
		logError("Failed on tz_call(). rc=%d.", -rc);
		goto err;
	}

err:
	mutex_unlock(&ctx.lock);

	return rc;
}

/*************************************************************************/

/*
 * This function removes a section of memory from TZ. The first section,
 * which is reserved for the kernel itself, will never be removed.
 *
 * @param   p               A pointer to a physical memory section.
 * @param   sz              Size of the memory section.
 *
 * @return  0               No Error.
 *          -ENODEV         TZ has not been initialized properly.
 *          -EFAULT         SMC call was not successful.
 *          -ERESTARTSYS    System interrupted mutex lock.
 *          +TZ_BIDE_NONCE_HASH_MISMATCH_PUBLIC   Nonce mismatch.
 */
int tz_remove_section(void *p,
		      unsigned sz)
{
	bide_remove_section_in_t *in = NULL;
	bide_remove_section_out_t *out = NULL;
	unsigned in_sz = sizeof(bide_remove_section_in_t);
	unsigned out_sz = sizeof(bide_remove_section_out_t);
	int rc = 0;

	if (!ctx.handle)
		return -ENODEV;

	if (mutex_lock_interruptible(&ctx.lock))
		return -ERESTARTSYS;

	/* Initialize the buffers and sizes */
	rc = tz_init_buffers((void **) &in, &in_sz, (void **) &out, &out_sz);
	if (rc) {
		logError("Failed on tz_get_buffers(). rc=%d.", -rc);
		goto err;
	}

	/* Set up the command */
	in->cmd  = TZ_CMD_BIDE_REMOVE_SECTION;
	in->addr = (uint32_t) (unsigned long) p;
	in->size = sz;

	/* Send the command to TZ */
	rc = tz_call((void *) in, in_sz, (void *) out, out_sz, in->nonce_hash);
	if (rc) {
		logError("Failed on tz_call(). rc=%d.", -rc);
		goto err;
	}

err:
	mutex_unlock(&ctx.lock);

	return rc;
}

/*************************************************************************/

/*
 * This function initializes the trustzone handle and calls into it to
 * get a nonce to secure future communications.
 *
 * Contents run only once, when netlink is notified that QSeeCom is initialized,
 * or when the BIDE device receives a TAKE_SNAPSHOT ioctl, whichever is first.
 *
 * @return  0               No Error.
 *          -EFAULT         SMC call was not successful.
 *          -EINVAL         Bad handle value.
 *          -ERESTARTSYS    System interrupted mutex lock.
 */
int tz_init_kernel(void)
{
	int rc = 0;

	/* If already initialized, ignore subsequent attempt */
	if (ctx.handle)
		return 0;

	logInfo("Initializing TZ.");

	/* Open a handle to the BlackBerry TA and allocate a page */
	rc = qseecom_start_app(&ctx.handle, "blackber", PAGE_SIZE);

	if (rc) {
		logError("Failed on qseecom_start_app(). rc=%d.", -rc);
		return rc;
	}

	/* Before any operation, secure the channel to TZ */
	rc = tz_get_nonce();
	if (rc) {
		logError("Failed on tz_get_nonce(). rc=%d.", -rc);
		return rc;
	}


	return 0;
}

/*************************************************************************/

/*
 * Clean up routine when system is being shut down.
 *
 * @return  0                   No Error.
 *          -EFAULT             SMC call was not successful.
 *          -EINVAL             Bad handle value.
 */
int tz_exit(void)
{
	/* Clean up handle */
	int rc = 0;
	rc = qseecom_shutdown_app(&ctx.handle);
	if (rc)
		logError("Failed on qseecom_shutdown_app(). rc=%d.", -rc);

	/* Free up mutex */
	mutex_destroy(&ctx.lock);

	return rc;
}

/*************************************************************************/

/*
 * Entry point for initialization.
 *
 * @return  0                   No Error.
 *          -ENOMEM             Out of memory for handle allocaiton.
 *          -EINVAL             Bad handle value.
 *          -EIO                Cannot load image.
 */
int tz_init(void)
{
	/* Initialize Mutex */
	mutex_init(&ctx.lock);

	return 0;
}
